/* Part 2: Parser */

/**
 *  Package and Import Specifications
 */
import java_cup.runtime.*;

/**
 *  Usercode Components
 */
parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }
:}

/* define how to connect to the scanner! */
scan with {: return s.next_token(); :};

/**
 *  Symbol Lists
 */

/* Terminals (tokens returned by the scanner). */
terminal               IF, ELSE, PREFIX, SUFFIX, PLUS, COMMA, RPAREN, FBODY, RCURLY;
terminal String        IDENTIFIER, FUNC, STRING_LITERAL;

/*  Non terminals */
non terminal           program;
non terminal String    def_list, def, def_args, def_expr, def_call, def_call_args, def_cond;
non terminal String    expr_list, expr, call, call_args, cond;

/**
 *  Precedence Declarations
 */
precedence left PREFIX, SUFFIX;
precedence left PLUS;
precedence nonassoc IF, ELSE;
precedence nonassoc FUNC;

/**
 *  The Grammar Rules
 */


//TODO: Make definitions and calls coexist. It works if a non-call expr is between them
program       ::= def_list:d expr_list:e                             {:System.out.println("public class Main {");
                                                                       System.out.println("\tpublic static void main(String[] args) {");
                                                                       System.out.printf("%s", e);
                                                                       System.out.println("\t}");
                                                                       System.out.printf("%s", d);
                                                                       System.out.println("}");
                                                                     :}
                ;

/* First Part: Function Declarations */
def_list      ::= def_list:rest def:f                                {: RESULT = String.format("%s\n%s\n", rest, f); :}
                |                                                    {: RESULT = ""; :}
                ;
def           ::= FUNC:f def_args:a FBODY def_expr:e RCURLY  {: RESULT = String.format("\tpublic static String %s%s) {\n\t\treturn %s;\n\t}", f, a, e); :}
                ;
def_args      ::= def_args:rest COMMA IDENTIFIER:i                   {: RESULT = String.format("%s, String %s", rest, i); :}
                | IDENTIFIER:i                                       {: RESULT = String.format("String %s", i); :}
                |                                                    {: RESULT = ""; :}
                ;
// Variable identifiers only allowed in function definitions... Otherwise expr, call, call_args, cond would 've been enough
def_expr      ::= def_call:f                                         {: RESULT = f; :}
                | IF def_cond:c RPAREN def_expr:e1 ELSE def_expr:e2  {: RESULT = String.format("(%s ? %s : %s)", c, e1, e2); :}
                | def_expr:e1 PLUS def_expr:e2                       {: RESULT = String.format("%s + %s", e1, e2); :}
                | IDENTIFIER:i                                       {: RESULT = i; :}
                | STRING_LITERAL:s                                   {: RESULT = String.format("\"%s\"", s); :}
                ;
def_call      ::= FUNC:f def_call_args:a RPAREN                          {: RESULT = String.format("%s%s)", f, a); :}
                ;
def_call_args ::= def_call_args:rest COMMA def_expr:e                {: RESULT = String.format("%s, %s", rest, e); :}
                | def_expr:e                                         {: RESULT = e; :}
                |                                                    {: RESULT = ""; :}
                ;
def_cond      ::= def_expr:e1 PREFIX def_expr:e2                     {: RESULT = String.format("(%s).startsWith(%s)", e2, e1); :}
                | def_expr:e1 SUFFIX def_expr:e2                     {: RESULT = String.format("(%s).endsWith(%s)", e2, e1); :}
                ;

/* Second Part: List of expressions to print (they all are/return Strings) */
expr_list     ::= expr_list:rest expr:e                              {: RESULT = String.format("%s\t\tSystem.out.println(%s);\n", rest, e); :}
                |                                                    {: RESULT = ""; :}
                ;
//TODO parentheses for complex expr?
expr          ::= call:f                                             {: RESULT = f; :}
                | IF cond:c RPAREN expr:e1 ELSE expr:e2              {: RESULT = String.format("(%s ? %s : %s)", c, e1, e2); :}
                | expr:e1 PLUS expr:e2                               {: RESULT = String.format("%s + %s", e1, e2); :}
                | STRING_LITERAL:s                                   {: RESULT = String.format("\"%s\"", s); :}
                ;
call          ::= FUNC:f call_args:a RPAREN                          {: RESULT = String.format("%s%s)", f, a); :}
                ;
call_args     ::= call_args:rest COMMA expr:e                        {: RESULT = String.format("%s, %s", rest, e); :}
                | expr:e                                             {: RESULT = e; :}
                |                                                    {: RESULT = ""; :}
                ;
cond          ::= expr:e1 PREFIX expr:e2                             {: RESULT = String.format("(%s).startsWith(%s)", e2, e1); :}
                | expr:e1 SUFFIX expr:e2                             {: RESULT = String.format("(%s).endsWith(%s)", e2, e1); :}
                ;
